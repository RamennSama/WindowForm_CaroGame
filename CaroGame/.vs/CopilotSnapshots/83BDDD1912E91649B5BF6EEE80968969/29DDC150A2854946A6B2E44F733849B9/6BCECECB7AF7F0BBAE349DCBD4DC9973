using System;
using System.Drawing;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Linq;

namespace WindowFormLastVersion
{
    public partial class CaroGameForm : Form
    {
        private const int BOARD_SIZE = 15; // 15x15 board
    private const int CELL_SIZE = 40;
        private const int MARGIN = 30;

        private Button[,] _board;
        private bool _isPlayerXTurn = true; // X goes first
      private bool _isPlayingWithComputer;
   private GameDifficulty _difficulty;

        public enum GameDifficulty
    {
         Easy,
Medium,
Hard
   }

        public CaroGameForm(bool playWithComputer = false, GameDifficulty difficulty = GameDifficulty.Easy)
   {
       InitializeComponent();
            _isPlayingWithComputer = playWithComputer;
       _difficulty = difficulty;
   SetupGame();
        }

        private void InitializeComponent()
     {
            Text = _isPlayingWithComputer ? $"Caro Game - Playing with Computer ({_difficulty})" : "Caro Game - 2 Players";
    ClientSize = new Size(BOARD_SIZE * CELL_SIZE + 2 * MARGIN, BOARD_SIZE * CELL_SIZE + 2 * MARGIN);
            BackColor = Color.White;
    FormBorderStyle = FormBorderStyle.FixedSingle;
         MaximizeBox = false;
            StartPosition = FormStartPosition.CenterScreen;
        }

        private void SetupGame()
        {
  _board = new Button[BOARD_SIZE, BOARD_SIZE];

  for (int i = 0; i < BOARD_SIZE; i++)
            {
        for (int j = 0; j < BOARD_SIZE; j++)
       {
  var cell = new Button
            {
      Location = new Point(MARGIN + j * CELL_SIZE, MARGIN + i * CELL_SIZE),
  Size = new Size(CELL_SIZE, CELL_SIZE),
 BackColor = Color.White,
            Font = new Font(Font.FontFamily, 16, FontStyle.Bold),
             Tag = new Point(i, j)
      };
         cell.Click += Cell_Click;
       Controls.Add(cell);
_board[i, j] = cell;
                }
  }
  }

        private void Cell_Click(object sender, EventArgs e)
        {
            var button = (Button)sender;
if (!string.IsNullOrEmpty(button.Text)) return;

          // Player's move
            button.Text = _isPlayerXTurn ? "X" : "O";
    button.ForeColor = _isPlayerXTurn ? Color.Blue : Color.Red;

            if (CheckWin((Point)button.Tag))
   {
                MessageBox.Show($"Player {(_isPlayerXTurn ? "X" : "O")} wins!");
      ResetGame();
                return;
     }

   _isPlayerXTurn = !_isPlayerXTurn;

            // Computer's move
    if (_isPlayingWithComputer && !_isPlayerXTurn)
    {
      MakeComputerMove();
            }
        }

        private void MakeComputerMove()
    {
            Point move = GetComputerMove();
 var button = _board[move.X, move.Y];
        button.Text = "O";
     button.ForeColor = Color.Red;

      if (CheckWin(move))
         {
       MessageBox.Show("Computer wins!");
                ResetGame();
     return;
         }

 _isPlayerXTurn = true;
        }

        private Point GetComputerMove()
        {
    switch (_difficulty)
  {
  case GameDifficulty.Easy:
           return GetRandomMove();
     case GameDifficulty.Medium:
     return Random.Shared.Next(0, 2) == 0 ? GetRandomMove() : GetSmartMove();
                case GameDifficulty.Hard:
     return GetSmartMove();
                default:
                    return GetRandomMove();
   }
  }

        private Point GetRandomMove()
        {
            var emptyCells = new List<Point>();
            for (int i = 0; i < BOARD_SIZE; i++)
       {
    for (int j = 0; j < BOARD_SIZE; j++)
 {
      if (string.IsNullOrEmpty(_board[i, j].Text))
        {
     emptyCells.Add(new Point(i, j));
     }
            }
      }
          int index = Random.Shared.Next(emptyCells.Count);
  return emptyCells[index];
    }

     private Point GetSmartMove()
        {
      if (_difficulty == GameDifficulty.Hard)
  {
     return GetHardMove();
    }
      else if (_difficulty == GameDifficulty.Medium)
            {
            return GetMediumMove();
        }
            return GetRandomMove();
     }

        private Point GetHardMove()
        {
        var possibleMoves = new List<MoveScore>();

            // Analyze every empty cell
            for (int i = 0; i < BOARD_SIZE; i++)
            {
            for (int j = 0; j < BOARD_SIZE; j++)
          {
      if (string.IsNullOrEmpty(_board[i, j].Text))
        {
             var score = EvaluateMove(i, j);
        possibleMoves.Add(new MoveScore { Move = new Point(i, j), Score = score });
        }
   }
  }

// Get the moves with the highest score
      if (possibleMoves.Any())
            {
       var maxScore = possibleMoves.Max(m => m.Score);
          var bestMoves = possibleMoves.Where(m => m.Score == maxScore).ToList();
    return bestMoves[Random.Shared.Next(bestMoves.Count)].Move;
  }

     return GetRandomMove();
        }

    private Point GetMediumMove()
        {
         // 80% chance to play like Hard difficulty
      if (Random.Shared.Next(100) < 80)
  {
         var possibleMoves = new List<MoveScore>();

          for (int i = 0; i < BOARD_SIZE; i++)
     {
        for (int j = 0; j < BOARD_SIZE; j++)
    {
            if (string.IsNullOrEmpty(_board[i, j].Text))
       {
        var score = EvaluateMove(i, j) / 2; // Reduce effectiveness
    possibleMoves.Add(new MoveScore { Move = new Point(i, j), Score = score });
  }
     }
           }

      if (possibleMoves.Any())
           {
  var maxScore = possibleMoves.Max(m => m.Score);
        var bestMoves = possibleMoves.Where(m => m.Score == maxScore).ToList();
      return bestMoves[Random.Shared.Next(bestMoves.Count)].Move;
         }
    }

            // 20% chance to play randomly near opponent's moves
   return FindNearbyMove() ?? GetRandomMove();
        }

        private int EvaluateMove(int x, int y)
   {
int score = 0;

  // Check both for computer ("O") and player ("X")
            foreach (var symbol in new[] { "O", "X" })
     {
      bool isComputer = symbol == "O";
       int multiplier = isComputer ? 1 : (symbol == "X" ? 2 : 0); // Prioritize blocking player

   _board[x, y].Text = symbol;

      // Evaluate all directions
              foreach (var direction in new[] { 
          (dx: 1, dy: 0),   // Horizontal
    (dx: 0, dy: 1),   // Vertical
         (dx: 1, dy: 1),   // Diagonal
         (dx: 1, dy: -1)   // Anti-diagonal
      })
      {
   int count = CountInDirection(x, y, direction.dx, direction.dy, symbol) +
  CountInDirection(x, y, -direction.dx, -direction.dy, symbol) - 1;

      // Scoring based on sequence length
         score += multiplier * CalculateSequenceScore(count);

        // Check for open ends
        int openEnds = CountOpenEnds(x, y, direction.dx, direction.dy, symbol);
         score += multiplier * openEnds * 5;

  // Special cases
           if (count >= 4) score += multiplier * 1000; // Immediate win/block
        if (count == 3 && openEnds == 2) score += multiplier * 500; // Double-sided three
         }

           _board[x, y].Text = "";
            }

            // Strategic position scoring
            score += EvaluatePosition(x, y);

     return score;
   }

        private int CalculateSequenceScore(int count)
     {
      return count switch
      {
       5 => 10000, // Win
    4 => 1000,  // One move from win
       3 => 100,   // Two moves from win
            2 => 10,    // Building sequence
                _ => 1      // Basic position
            };
  }

        private int CountOpenEnds(int x, int y, int dx, int dy, string symbol)
        {
   int openEnds = 0;
   
 // Check one end
            int nextX = x + dx * (CountInDirection(x, y, dx, dy, symbol));
            int nextY = y + dy * (CountInDirection(x, y, dx, dy, symbol));
     if (IsValidPosition(nextX, nextY) && string.IsNullOrEmpty(_board[nextX, nextY].Text))
         openEnds++;

  // Check other end
      nextX = x - dx * (CountInDirection(x, y, -dx, -dy, symbol));
      nextY = y - dy * (CountInDirection(x, y, -dx, -dy, symbol));
    if (IsValidPosition(nextX, nextY) && string.IsNullOrEmpty(_board[nextX, nextY].Text))
     openEnds++;

            return openEnds;
 }

        private bool IsValidPosition(int x, int y)
        {
            return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;
        }

  private int EvaluatePosition(int x, int y)
        {
    // Center positions are more valuable
     int centerX = BOARD_SIZE / 2;
   int centerY = BOARD_SIZE / 2;
   int distanceFromCenter = Math.Abs(x - centerX) + Math.Abs(y - centerY);
 int positionScore = (BOARD_SIZE - distanceFromCenter) * 2;

  // Positions near existing pieces are more valuable
            int nearbyPieces = CountNearbyPieces(x, y);
          positionScore += nearbyPieces * 5;

            return positionScore;
        }

        private int CountNearbyPieces(int x, int y)
     {
            int count = 0;
       for (int i = -1; i <= 1; i++)
     {
              for (int j = -1; j <= 1; j++)
      {
  if (i == 0 && j == 0) continue;
      int newX = x + i;
  int newY = y + j;
        if (IsValidPosition(newX, newY) && !string.IsNullOrEmpty(_board[newX, newY].Text))
   {
   count++;
           }
       }
   }
       return count;
        }

     // ... keep existing helper methods ...
    }
}