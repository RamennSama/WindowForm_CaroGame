using System;
using System.Drawing;
using System.Windows.Forms;

namespace WindowFormLastVersion
{
    public partial class CaroGameForm : Form
    {
        private const int BOARD_SIZE = 15; // 15x15 board
    private const int CELL_SIZE = 40;
        private const int MARGIN = 30;

        private Button[,] _board;
        private bool _isPlayerXTurn = true; // X goes first
      private bool _isPlayingWithComputer;
   private GameDifficulty _difficulty;

        public enum GameDifficulty
    {
         Easy,
Medium,
Hard
   }

        public CaroGameForm(bool playWithComputer = false, GameDifficulty difficulty = GameDifficulty.Easy)
   {
       InitializeComponent();
            _isPlayingWithComputer = playWithComputer;
       _difficulty = difficulty;
   SetupGame();
        }

        private void InitializeComponent()
     {
            Text = _isPlayingWithComputer ? $"Caro Game - Playing with Computer ({_difficulty})" : "Caro Game - 2 Players";
    ClientSize = new Size(BOARD_SIZE * CELL_SIZE + 2 * MARGIN, BOARD_SIZE * CELL_SIZE + 2 * MARGIN);
            BackColor = Color.White;
    FormBorderStyle = FormBorderStyle.FixedSingle;
         MaximizeBox = false;
            StartPosition = FormStartPosition.CenterScreen;
        }

        private void SetupGame()
        {
  _board = new Button[BOARD_SIZE, BOARD_SIZE];

  for (int i = 0; i < BOARD_SIZE; i++)
            {
        for (int j = 0; j < BOARD_SIZE; j++)
       {
  var cell = new Button
            {
      Location = new Point(MARGIN + j * CELL_SIZE, MARGIN + i * CELL_SIZE),
  Size = new Size(CELL_SIZE, CELL_SIZE),
 BackColor = Color.White,
            Font = new Font(Font.FontFamily, 16, FontStyle.Bold),
             Tag = new Point(i, j)
      };
         cell.Click += Cell_Click;
       Controls.Add(cell);
_board[i, j] = cell;
                }
  }
  }

        private void Cell_Click(object sender, EventArgs e)
        {
            var button = (Button)sender;
if (!string.IsNullOrEmpty(button.Text)) return;

          // Player's move
            button.Text = _isPlayerXTurn ? "X" : "O";
    button.ForeColor = _isPlayerXTurn ? Color.Blue : Color.Red;

            if (CheckWin((Point)button.Tag))
   {
                MessageBox.Show($"Player {(_isPlayerXTurn ? "X" : "O")} wins!");
      ResetGame();
                return;
     }

   _isPlayerXTurn = !_isPlayerXTurn;

            // Computer's move
    if (_isPlayingWithComputer && !_isPlayerXTurn)
    {
      MakeComputerMove();
            }
        }

        private void MakeComputerMove()
    {
            Point move = GetComputerMove();
 var button = _board[move.X, move.Y];
        button.Text = "O";
     button.ForeColor = Color.Red;

      if (CheckWin(move))
         {
       MessageBox.Show("Computer wins!");
                ResetGame();
     return;
         }

 _isPlayerXTurn = true;
        }

        private Point GetComputerMove()
        {
    switch (_difficulty)
  {
  case GameDifficulty.Easy:
           return GetRandomMove();
     case GameDifficulty.Medium:
     return Random.Shared.Next(0, 2) == 0 ? GetRandomMove() : GetSmartMove();
                case GameDifficulty.Hard:
     return GetSmartMove();
                default:
                    return GetRandomMove();
   }
  }

        private Point GetRandomMove()
        {
            var emptyCells = new List<Point>();
            for (int i = 0; i < BOARD_SIZE; i++)
       {
    for (int j = 0; j < BOARD_SIZE; j++)
 {
      if (string.IsNullOrEmpty(_board[i, j].Text))
        {
     emptyCells.Add(new Point(i, j));
     }
            }
      }
          int index = Random.Shared.Next(emptyCells.Count);
  return emptyCells[index];
    }

     private Point GetSmartMove()
        {
     // Simple smart move: Check if can win or need to block
            for (int i = 0; i < BOARD_SIZE; i++)
      {
            for (int j = 0; j < BOARD_SIZE; j++)
                {
        if (string.IsNullOrEmpty(_board[i, j].Text))
  {
           // Try winning move
  _board[i, j].Text = "O";
       if (CheckWin(new Point(i, j)))
    {
       _board[i, j].Text = "";
            return new Point(i, j);
     }
            _board[i, j].Text = "";

     // Try blocking move
       _board[i, j].Text = "X";
   if (CheckWin(new Point(i, j)))
    {
     _board[i, j].Text = "";
  return new Point(i, j);
 }
        _board[i, j].Text = "";
 }
      }
       }
      return GetRandomMove();
        }

 private bool CheckWin(Point lastMove)
 {
     string symbol = _board[lastMove.X, lastMove.Y].Text;
            
       // Check horizontal
  int count = 1;
    int i = lastMove.Y - 1;
  while (i >= 0 && _board[lastMove.X, i].Text == symbol) { count++; i--; }
          i = lastMove.Y + 1;
       while (i < BOARD_SIZE && _board[lastMove.X, i].Text == symbol) { count++; i++; }
        if (count >= 5) return true;

 // Check vertical
    count = 1;
            i = lastMove.X - 1;
            while (i >= 0 && _board[i, lastMove.Y].Text == symbol) { count++; i--; }
    i = lastMove.X + 1;
            while (i < BOARD_SIZE && _board[i, lastMove.Y].Text == symbol) { count++; i++; }
 if (count >= 5) return true;

       // Check diagonal
      count = 1;
   i = 1;
            while (lastMove.X - i >= 0 && lastMove.Y - i >= 0 && _board[lastMove.X - i, lastMove.Y - i].Text == symbol) { count++; i++; }
    i = 1;
  while (lastMove.X + i < BOARD_SIZE && lastMove.Y + i < BOARD_SIZE && _board[lastMove.X + i, lastMove.Y + i].Text == symbol) { count++; i++; }
          if (count >= 5) return true;

            // Check anti-diagonal
            count = 1;
      i = 1;
 while (lastMove.X - i >= 0 && lastMove.Y + i < BOARD_SIZE && _board[lastMove.X - i, lastMove.Y + i].Text == symbol) { count++; i++; }
            i = 1;
    while (lastMove.X + i < BOARD_SIZE && lastMove.Y - i >= 0 && _board[lastMove.X + i, lastMove.Y - i].Text == symbol) { count++; i++; }
       if (count >= 5) return true;

            return false;
        }

        private void ResetGame()
        {
    foreach (var button in _board)
         {
      button.Text = "";
  }
            _isPlayerXTurn = true;
        }
  }
}