using System;
using System.Drawing;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Linq;

namespace WindowFormLastVersion
{
    public partial class CaroGameForm : Form
    {
        // Game Logic Fields
        private bool _isPlayerXTurn = true; // X goes first
        private bool _isPlayingWithComputer;
        private GameDifficulty _difficulty;

        // Constants
        private const int BoardSize = 15;
        private const int CellSize = 40;
        private const int Margin = 30;
        private const int MaxGames = 5;

        private Button[,] gameBoard;
        private string playerXName = "Player X";
        private string playerOName = "Player O";
        private int playerXScore = 0;
        private int playerOScore = 0;
        private int gamesPlayed = 0;
        private Label scoreLabel;

        public enum GameDifficulty
        {
            Easy,
            Medium,
            Hard
        }

        public CaroGameForm(bool playWithComputer = false, GameDifficulty difficulty = GameDifficulty.Easy)
        {
            _isPlayingWithComputer = playWithComputer;
            _difficulty = difficulty;
            
            if (!playWithComputer)
            {
                // For 2-player mode, ask for names
                using var nameDialog = new NameInputDialog();
                if (nameDialog.ShowDialog() == DialogResult.OK)
                {
                    playerXName = nameDialog.PlayerXName;
                    playerOName = nameDialog.PlayerOName;
                }
            }
            
            InitializeComponentCustom();
            SetupGame();
            
            this.FormClosing += CaroGameForm_FormClosing;
        }

        private void InitializeComponentCustom()
        {
            Text = _isPlayingWithComputer ? $"Caro Game - Playing with Computer ({_difficulty})" : $"Caro Game - {playerXName} vs {playerOName}";
            ClientSize = new Size(BoardSize * CellSize + 2 * Margin, BoardSize * CellSize + 2 * Margin + 100);
            BackColor = Color.White;
            FormBorderStyle = FormBorderStyle.FixedSingle;
            MaximizeBox = false;
            StartPosition = FormStartPosition.CenterScreen;

            // Add score label
            scoreLabel = new Label
            {
                Text = GetScoreText(),
                Location = new Point(Margin, BoardSize * CellSize + Margin + 10),
                Size = new Size(ClientSize.Width - 2 * Margin, 40),
                Font = new Font(Font.FontFamily, 12, FontStyle.Bold),
                TextAlign = ContentAlignment.MiddleCenter
            };
            Controls.Add(scoreLabel);
        }

        private string GetScoreText()
        {
            if (_isPlayingWithComputer)
            {
                return $"Games Played: {gamesPlayed}";
            }
            else
            {
                return $"{playerXName}: {playerXScore} - {playerOName}: {playerOScore} (Game {gamesPlayed + 1}/{MaxGames})";
            }
        }

        private void SetupGame()
        {
            gameBoard = new Button[BoardSize, BoardSize];

            for (int i = 0; i < BoardSize; i++)
            {
                for (int j = 0; j < BoardSize; j++)
                {
                    var cell = new Button
                    {
                        Location = new Point(Margin + j * CellSize, Margin + i * CellSize),
                        Size = new Size(CellSize, CellSize),
                        BackColor = Color.White,
                        Font = new Font(Font.FontFamily, 16, FontStyle.Bold),
                        Tag = new Point(i, j)
                    };
                    cell.Click += Cell_Click;
                    Controls.Add(cell);
                    gameBoard[i, j] = cell;
                }
            }
        }

        private void Cell_Click(object sender, EventArgs e)
        {
            var button = (Button)sender;
            if (!string.IsNullOrEmpty(button.Text)) return;

            // Player's move
            button.Text = _isPlayerXTurn ? "X" : "O";
            button.ForeColor = _isPlayerXTurn ? Color.Blue : Color.Red;

            if (CheckWin((Point)button.Tag))
            {
                string winnerName = _isPlayerXTurn ? playerXName : playerOName;
                MessageBox.Show($"{winnerName} wins!");
                
                if (!_isPlayingWithComputer)
                {
                    // Update scores for 2-player mode
                    if (_isPlayerXTurn)
                        playerXScore++;
                    else
                        playerOScore++;
                    
                    gamesPlayed++;
                    
                    if (gamesPlayed >= MaxGames)
                    {
                        // End tournament
                        string finalWinner = playerXScore > playerOScore ? playerXName : 
                                           playerOScore > playerXScore ? playerOName : "Draw";
                        MessageBox.Show($"Tournament Over!\nFinal Winner: {finalWinner}\n{playerXName}: {playerXScore} - {playerOName}: {playerOScore}");
                        this.DialogResult = DialogResult.OK;
                        this.Close();
                        return;
                    }
                    else
                    {
                        // Continue to next game
                        ResetGame();
                        scoreLabel.Text = GetScoreText();
                        return;
                    }
                }
                else
                {
                    // Single game with computer
                    ResetGame();
                    return;
                }
            }

            _isPlayerXTurn = !_isPlayerXTurn;

            // Computer's move
            if (_isPlayingWithComputer && !_isPlayerXTurn)
            {
                MakeComputerMove();
            }
        }

        private void MakeComputerMove()
        {
            Point move = GetComputerMove();
            var button = gameBoard[move.X, move.Y];
            button.Text = "O";
            button.ForeColor = Color.Red;

            if (CheckWin(move))
            {
                MessageBox.Show("Computer wins!");
                ResetGame();
                return;
            }

            _isPlayerXTurn = true;
        }

        private Point GetComputerMove()
        {
            switch (_difficulty)
            {
                case GameDifficulty.Easy:
                    return GetRandomMove();
                case GameDifficulty.Medium:
                    return Random.Shared.Next(0, 2) == 0 ? GetRandomMove() : GetSmartMove();
                case GameDifficulty.Hard:
                    return GetSmartMove();
                default:
                    return GetRandomMove();
            }
        }

        private Point GetRandomMove()
        {
            var emptyCells = new List<Point>();
            for (int i = 0; i < BoardSize; i++)
            {
                for (int j = 0; j < BoardSize; j++)
                {
                    if (string.IsNullOrEmpty(gameBoard[i, j].Text))
                    {
                        emptyCells.Add(new Point(i, j));
                    }
                }
            }
            int index = Random.Shared.Next(emptyCells.Count);
            return emptyCells[index];
        }

        private Point GetSmartMove()
        {
            if (_difficulty == GameDifficulty.Hard)
            {
                return GetHardMove();
            }
            else if (_difficulty == GameDifficulty.Medium)
            {
                return Random.Shared.Next(100) < 85 ? GetHardMove() : GetRandomMove();
            }
            return GetRandomMove();
        }

        private Point GetHardMove()
        {
            var possibleMoves = new List<MoveScore>();

            // Analyze every empty cell
            for (int i = 0; i < BoardSize; i++)
            {
                for (int j = 0; j < BoardSize; j++)
                {
                    if (string.IsNullOrEmpty(gameBoard[i, j].Text))
                    {
                        var score = EvaluateMove(i, j);
                        possibleMoves.Add(new MoveScore { Move = new Point(i, j), Score = score });
                    }
                }
            }

            // Get the moves with the highest score
            if (possibleMoves.Any())
            {
                var maxScore = possibleMoves.Max(m => m.Score);
                var bestMoves = possibleMoves.Where(m => m.Score == maxScore).ToList();
                return bestMoves[Random.Shared.Next(bestMoves.Count)].Move;
            }

            return GetRandomMove();
        }

        private Point GetMediumMove()
        {
            // 95% chance to play strategically
            if (Random.Shared.Next(100) < 95)
            {
                var possibleMoves = new List<MoveScore>();

                for (int i = 0; i < BoardSize; i++)
                {
                    for (int j = 0; j < BoardSize; j++)
                    {
                        if (string.IsNullOrEmpty(gameBoard[i, j].Text))
                        {
                            var score = EvaluateMove(i, j) * 0.85; // Using 85% of hard mode effectiveness
                            
                            // Bonus points for moves that block opponent's winning moves
                            if (IsBlockingMove(i, j))
                            {
                                score *= 1.5;
                            }
                            
                            possibleMoves.Add(new MoveScore { Move = new Point(i, j), Score = (int)score });
                        }
                    }
                }

                if (possibleMoves.Any())
                {
                    // Get top 2 moves instead of 3 to be more competitive
                    var topMoves = possibleMoves
                        .OrderByDescending(m => m.Score)
                        .Take(2)
                        .ToList();
                    return topMoves[Random.Shared.Next(topMoves.Count)].Move;
                }
            }

            // 5% chance to play randomly near existing pieces
            return FindNearbyMove() ?? GetRandomMove();
        }

        private bool IsBlockingMove(int x, int y)
        {
            gameBoard[x, y].Text = "X"; // Temporarily place player's mark
            
            // Check if this position would block a potential win
            foreach (var direction in new[] { 
                (dx: 1, dy: 0),   // Horizontal
                (dx: 0, dy: 1),   // Vertical
                (dx: 1, dy: 1),   // Diagonal
                (dx: 1, dy: -1)   // Anti-diagonal
            })
            {
                int count = CountInDirection(x, y, direction.dx, direction.dy, "X") +
                           CountInDirection(x, y, -direction.dx, -direction.dy, "X") - 1;
                   
                if (count >= 3) // If it blocks 4 or more in a row
                {
                    gameBoard[x, y].Text = ""; // Reset the cell
                    return true;
                }
            }
            
            gameBoard[x, y].Text = ""; // Reset the cell
            return false;
        }

        private int EvaluateMove(int x, int y)
        {    
            int score = 0;

            // Check both for computer ("O") and player ("X")
            foreach (var symbol in new[] { "O", "X" })
            {
                bool isComputer = symbol == "O";
                int multiplier = isComputer ? 1 : (symbol == "X" ? 2 : 0); // Prioritize blocking player

                gameBoard[x, y].Text = symbol;

                // Evaluate all directions
                foreach (var direction in new[] { 
                    (dx: 1, dy: 0),   // Horizontal
                    (dx: 0, dy: 1),   // Vertical
                    (dx: 1, dy: 1),   // Diagonal
                    (dx: 1, dy: -1)   // Anti-diagonal
                })
                {
                    int count = CountInDirection(x, y, direction.dx, direction.dy, symbol) +
                                CountInDirection(x, y, -direction.dx, -direction.dy, symbol) - 1;

                    // Scoring based on sequence length
                    score += multiplier * CalculateSequenceScore(count);

                    // Check for open ends
                    int openEnds = CountOpenEnds(x, y, direction.dx, direction.dy, symbol);
                    score += multiplier * openEnds * 5;

                    // Special cases
                    if (count >= 4) score += multiplier * 1000; // Immediate win/block
                    if (count == 3 && openEnds == 2) score += multiplier * 500; // Double-sided three
                }

                gameBoard[x, y].Text = "";
            }

            // Strategic position scoring
            score += EvaluatePosition(x, y);

            return score;
        }

        private int CalculateSequenceScore(int count)
        {
            return count switch
            {
                5 => 10000, // Win
                4 => 1000,  // One move from win
                3 => 100,   // Two moves from win
                2 => 10,    // Building sequence
                _ => 1      // Basic position
            };
        }

        private int CountOpenEnds(int x, int y, int dx, int dy, string symbol)
        {
            int openEnds = 0;
            
            // Check one end
            int nextX = x + dx * (CountInDirection(x, y, dx, dy, symbol));
            int nextY = y + dy * (CountInDirection(x, y, dx, dy, symbol));
            if (IsValidPosition(nextX, nextY) && string.IsNullOrEmpty(gameBoard[nextX, nextY].Text))
                openEnds++;

            // Check other end
            nextX = x - dx * (CountInDirection(x, y, -dx, -dy, symbol));
            nextY = y - dy * (CountInDirection(x, y, -dx, -dy, symbol));
            if (IsValidPosition(nextX, nextY) && string.IsNullOrEmpty(gameBoard[nextX, nextY].Text))
                openEnds++;

            return openEnds;
        }

        private bool IsValidPosition(int x, int y)
        {
            return x >= 0 && x < BoardSize && y >= 0 && y < BoardSize;
        }

        private int EvaluatePosition(int x, int y)
        {
            // Center positions are more valuable
            int centerX = BoardSize / 2;
            int centerY = BoardSize / 2;
            int distanceFromCenter = Math.Abs(x - centerX) + Math.Abs(y - centerY);
            int positionScore = (BoardSize - distanceFromCenter) * 2;

            // Positions near existing pieces are more valuable
            int nearbyPieces = CountNearbyPieces(x, y);
            positionScore += nearbyPieces * 5;

            return positionScore;
        }

        private int CountNearbyPieces(int x, int y)
        {
            int count = 0;
            for (int i = -1; i <= 1; i++)
            {
                for (int j = -1; j <= 1; j++)
                {
                    if (i == 0 && j == 0) continue;
                    int newX = x + i;
                    int newY = y + j;
                    if (IsValidPosition(newX, newY) && !string.IsNullOrEmpty(gameBoard[newX, newY].Text))
                    {
                        count++;
                    }
                }
            }
            return count;
        }

        private void ResetGame()
        {
            // Clear all cells and reset turn
            for (int i = 0; i < BoardSize; i++)
            {
                for (int j = 0; j < BoardSize; j++)
                {
                    gameBoard[i, j].Text = "";
                    gameBoard[i, j].ForeColor = Color.Black;
                }
            }
            _isPlayerXTurn = true;
        }

        private bool CheckWin(Point move)
        {
            string symbol = gameBoard[move.X, move.Y].Text;
            foreach (var direction in new[] {
                (dx: 1, dy: 0),   // Horizontal
                (dx: 0, dy: 1),   // Vertical
                (dx: 1, dy: 1),   // Diagonal
                (dx: 1, dy: -1)   // Anti-diagonal
            })
            {
                if (CountInDirection(move.X, move.Y, direction.dx, direction.dy, symbol) +
                    CountInDirection(move.X, move.Y, -direction.dx, -direction.dy, symbol) - 1 >= 5)
                {
                    return true;
                }
            }
            return false;
        }

        private int CountInDirection(int x, int y, int dx, int dy, string symbol)
        {
            int count = 0;
            while (IsValidPosition(x, y) && gameBoard[x, y].Text == symbol)
            {
                count++;
                x += dx;
                y += dy;
            }
            return count;
        }

        private Point? FindNearbyMove()
        {
            var emptyCells = new List<Point>();
            for (int i = 0; i < BoardSize; i++)
            {
                for (int j = 0; j < BoardSize; j++)
                {
                    if (string.IsNullOrEmpty(gameBoard[i, j].Text) && CountNearbyPieces(i, j) > 0)
                    {
                        emptyCells.Add(new Point(i, j));
                    }
                }
            }
            return emptyCells.Any() ? emptyCells[Random.Shared.Next(emptyCells.Count)] : null;
        }

        private void CaroGameForm_FormClosing(object sender, FormClosingEventArgs e)
        {
            // Handle form closing - you can add confirmation logic here if needed
        }

        private void UpdateScore(int xScore, int oScore)
        {
            playerXScore += xScore;
            playerOScore += oScore;
            gamesPlayed++;

            scoreLabel.Text = GetScoreText();

            // Reset player names if max games reached
            if (gamesPlayed >= MaxGames)
            {
                MessageBox.Show($"{playerXName}: {playerXScore} - {playerOName}: {playerOScore}\n\nMax games reached. Restarting...");
                playerXScore = 0;
                playerOScore = 0;
                gamesPlayed = 0;
                scoreLabel.Text = GetScoreText();
            }
        }

        private class MoveScore
        {
            public Point Move { get; set; }
            public int Score { get; set; }
        }
    }
}