using System;
using System.Drawing;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Linq;

namespace WindowFormLastVersion
{
    public partial class CaroGameForm : Form
    {
        // Remove duplicate field declarations if they exist in Designer.cs
        #region Game Logic Fields
        private bool _isPlayerXTurn;
        private bool _isPlayingWithComputer;
        private GameDifficulty _difficulty;
        #endregion

        public enum GameDifficulty
        {
            Easy,
            Medium,
            Hard
        }

        public CaroGameForm(bool playWithComputer = false, GameDifficulty difficulty = GameDifficulty.Easy)
        {
            _isPlayingWithComputer = playWithComputer;
            _difficulty = difficulty;
            InitializeComponent();
            InitializeComponentCustom(); // Add this line to call your custom initialization
            SetupGame();
            
            this.FormClosing += CaroGameForm_FormClosing;
        }

        private void InitializeComponentCustom()
        {
            Text = _isPlayingWithComputer ? $"Caro Game - Playing with Computer ({_difficulty})" : "Caro Game - 2 Players";
            ClientSize = new Size(BoardSize * CellSize + 2 * Margin, BoardSize * CellSize + 2 * Margin + 50);
            BackColor = Color.White;
            FormBorderStyle = FormBorderStyle.FixedSingle;
            MaximizeBox = false;
            StartPosition = FormStartPosition.CenterScreen;
        }

        #region Constants (Move these to Designer.cs if they're duplicated)
        protected const int BoardSize = 15;
        protected const int CellSize = 40;
        protected const int Margin = 30;
        #endregion

        private void SetupGame()
        {
            gameBoard = new Button[BoardSize, BoardSize];

            for (int i = 0; i < BoardSize; i++)
            {
                for (int j = 0; j < BoardSize; j++)
                {
                    var cell = new Button
                    {
                        Location = new Point(Margin + j * CellSize, Margin + i * CellSize),
                        Size = new Size(CellSize, CellSize),
                        BackColor = Color.White,
                        Font = new Font(Font.FontFamily, 16, FontStyle.Bold),
                        Tag = new Point(i, j)
                    };
                    cell.Click += Cell_Click!;
                    Controls.Add(cell);
                    gameBoard[i, j] = cell;
                }
            }
        }

        // Add this field to replace _board if it's duplicated
        private Button[,] gameBoard = null!;

        private void Cell_Click(object sender, EventArgs e)
        {
            var button = (Button)sender;
            if (!string.IsNullOrEmpty(button.Text)) return;

            // Player's move
            button.Text = _isPlayerXTurn ? "X" : "O";
            button.ForeColor = _isPlayerXTurn ? Color.Blue : Color.Red;

            if (CheckWin((Point)button.Tag!))
            {
                MessageBox.Show($"Player {(_isPlayerXTurn ? "X" : "O")} wins!");
                ResetGame();
                return;
            }

            _isPlayerXTurn = !_isPlayerXTurn;

            // Computer's move
            if (_isPlayingWithComputer && !_isPlayerXTurn)
            {
                MakeComputerMove();
            }
        }

        private void MakeComputerMove()
        {
            Point move = GetComputerMove();
            var button = gameBoard[move.X, move.Y];
            button.Text = "O";
            button.ForeColor = Color.Red;

            if (CheckWin(move))
            {
                MessageBox.Show("Computer wins!");
                ResetGame();
                return;
            }

            _isPlayerXTurn = true;
        }

        private Point GetComputerMove()
        {
            switch (_difficulty)
            {
                case GameDifficulty.Easy:
                    return GetRandomMove();
                case GameDifficulty.Medium:
                    return Random.Shared.Next(0, 2) == 0 ? GetRandomMove() : GetSmartMove();
                case GameDifficulty.Hard:
                    return GetSmartMove();
                default:
                    return GetRandomMove();
            }
        }

        private Point GetRandomMove()
        {
            var emptyCells = new List<Point>();
            for (int i = 0; i < BoardSize; i++)
            {
                for (int j = 0; j < BoardSize; j++)
                {
                    if (string.IsNullOrEmpty(gameBoard[i, j].Text))
                    {
                        emptyCells.Add(new Point(i, j));
                    }
                }
            }
            int index = Random.Shared.Next(emptyCells.Count);
            return emptyCells[index];
        }

        private Point GetSmartMove()
        {
            if (_difficulty == GameDifficulty.Hard)
            {
                return GetHardMove();
            }
            else if (_difficulty == GameDifficulty.Medium)
            {
                return Random.Shared.Next(100) < 85 ? GetSmartMove() : GetRandomMove();
            }
            return GetRandomMove();
        }

        private Point GetHardMove()
        {
            var possibleMoves = new List<MoveScore>();

            // Analyze every empty cell
            for (int i = 0; i < BoardSize; i++)
            {
                for (int j = 0; j < BoardSize; j++)
                {
                    if (string.IsNullOrEmpty(gameBoard[i, j].Text))
                    {
                        var score = EvaluateMove(i, j);
                        possibleMoves.Add(new MoveScore { Move = new Point(i, j), Score = score });
                    }
                }
            }

            // Get the moves with the highest score
            if (possibleMoves.Any())
            {
                var maxScore = possibleMoves.Max(m => m.Score);
                var bestMoves = possibleMoves.Where(m => m.Score == maxScore).ToList();
                return bestMoves[Random.Shared.Next(bestMoves.Count)].Move;
            }

            return GetRandomMove();
        }

        private Point GetMediumMove()
        {
            // 95% chance to play strategically
            if (Random.Shared.Next(100) < 95)
            {
                var possibleMoves = new List<MoveScore>();

                for (int i = 0; i < BoardSize; i++)
                {
                    for (int j = 0; j < BoardSize; j++)
                    {
                        if (string.IsNullOrEmpty(gameBoard[i, j].Text))
                        {
                            var score = EvaluateMove(i, j) * 0.85; // Using 85% of hard mode effectiveness
                            
                            // Bonus points for moves that block opponent's winning moves
                            if (IsBlockingMove(i, j))
                            {
                                score *= 1.5;
                            }
                            
                            possibleMoves.Add(new MoveScore { Move = new Point(i, j), Score = (int)score });
                        }
                    }
                }

                if (possibleMoves.Any())
                {
                    // Get top 2 moves instead of 3 to be more competitive
                    var topMoves = possibleMoves
                        .OrderByDescending(m => m.Score)
                        .Take(2)
                        .ToList();
                    return topMoves[Random.Shared.Next(topMoves.Count)].Move;
                }
            }

            // 5% chance to play randomly near existing pieces
            return FindNearbyMove() ?? GetRandomMove();
        }

        private bool IsBlockingMove(int x, int y)
        {
            gameBoard[x, y].Text = "X"; // Temporarily place player's mark
            
            // Check if this position would block a potential win
            foreach (var direction in new[] { 
                (dx: 1, dy: 0),   // Horizontal
                (dx: 0, dy: 1),   // Vertical
                (dx: 1, dy: 1),   // Diagonal
                (dx: 1, dy: -1)   // Anti-diagonal
            })
            {
                int count = CountInDirection(x, y, direction.dx, direction.dy, "X") +
                           CountInDirection(x, y, -direction.dx, -direction.dy, "X") - 1;
                   
                if (count >= 3) // If it blocks 4 or more in a row
                {
                    gameBoard[x, y].Text = ""; // Reset the cell
                    return true;
                }
            }
            
            gameBoard[x, y].Text = ""; // Reset the cell
            return false;
        }

        private int EvaluateMove(int x, int y)
        {    
            int score = 0;

            // Check both for computer ("O") and player ("X")
            foreach (var symbol in new[] { "O", "X" })
            {
                bool isComputer = symbol == "O";
                int multiplier = isComputer ? 1 : (symbol == "X" ? 2 : 0); // Prioritize blocking player

                gameBoard[x, y].Text = symbol;

                // Evaluate all directions
                foreach (var direction in new[] { 
                    (dx: 1, dy: 0),   // Horizontal
                    (dx: 0, dy: 1),   // Vertical
                    (dx: 1, dy: 1),   // Diagonal
                    (dx: 1, dy: -1)   // Anti-diagonal
                })
                {
                    int count = CountInDirection(x, y, direction.dx, direction.dy, symbol) +
                                CountInDirection(x, y, -direction.dx, -direction.dy, symbol) - 1;

                    // Scoring based on sequence length
                    score += multiplier * CalculateSequenceScore(count);

                    // Check for open ends
                    int openEnds = CountOpenEnds(x, y, direction.dx, direction.dy, symbol);
                    score += multiplier * openEnds * 5;

                    // Special cases
                    if (count >= 4) score += multiplier * 1000; // Immediate win/block
                    if (count == 3 && openEnds == 2) score += multiplier * 500; // Double-sided three
                }

                gameBoard[x, y].Text = "";
            }

            // Strategic position scoring
            score += EvaluatePosition(x, y);

            return score;
        }

        private int CalculateSequenceScore(int count)
        {
            return count switch
            {
                5 => 10000, // Win
                4 => 1000,  // One move from win
                3 => 100,   // Two moves from win
                2 => 10,    // Building sequence
                _ => 1      // Basic position
            };
        }

        private int CountOpenEnds(int x, int y, int dx, int dy, string symbol)
        {
            int openEnds = 0;
            
            // Check one end
            int nextX = x + dx * (CountInDirection(x, y, dx, dy, symbol));
            int nextY = y + dy * (CountInDirection(x, y, dx, dy, symbol));
            if (IsValidPosition(nextX, nextY) && string.IsNullOrEmpty(gameBoard[nextX, nextY].Text))
                openEnds++;

            // Check other end
            nextX = x - dx * (CountInDirection(x, y, -dx, -dy, symbol));
            nextY = y - dy * (CountInDirection(x, y, -dx, -dy, symbol));
            if (IsValidPosition(nextX, nextY) && string.IsNullOrEmpty(gameBoard[nextX, nextY].Text))
                openEnds++;

            return openEnds;
        }

        private bool IsValidPosition(int x, int y)
        {
            return x >= 0 && x < BoardSize && y >= 0 && y < BoardSize;
        }

        private int EvaluatePosition(int x, int y)
        {
            // Center positions are more valuable
            int centerX = BoardSize / 2;
            int centerY = BoardSize / 2;
            int distanceFromCenter = Math.Abs(x - centerX) + Math.Abs(y - centerY);
            int positionScore = (BoardSize - distanceFromCenter) * 2;

            // Positions near existing pieces are more valuable
            int nearbyPieces = CountNearbyPieces(x, y);
            positionScore += nearbyPieces * 5;

            return positionScore;
        }

        private int CountNearbyPieces(int x, int y)
        {
            int count = 0;
            for (int i = -1; i <= 1; i++)
            {
                for (int j = -1; j <= 1; j++)
                {
                    if (i == 0 && j == 0) continue;
                    int newX = x + i;
                    int newY = y + j;
                    if (IsValidPosition(newX, newY) && !string.IsNullOrEmpty(gameBoard[newX, newY].Text))
                    {
                        count++;
                    }
                }
            }
            return count;
        }

        private void ResetGame()
        {
            // Clear all cells and reset turn
            for (int i = 0; i < BoardSize; i++)
            {
                for (int j = 0; j < BoardSize; j++)
                {
                    gameBoard[i, j].Text = "";
                    gameBoard[i, j].ForeColor = Color.Black;
                }
            }
            _isPlayerXTurn = true;
        }

        private bool CheckWin(Point move)
        {
            string symbol = gameBoard[move.X, move.Y].Text;
            foreach (var direction in new[] {
                (dx: 1, dy: 0),   // Horizontal
                (dx: 0, dy: 1),   // Vertical
                (dx: 1, dy: 1),   // Diagonal
                (dx: 1, dy: -1)   // Anti-diagonal
            })
            {
                if (CountInDirection(move.X, move.Y, direction.dx, direction.dy, symbol) +
                    CountInDirection(move.X, move.Y, -direction.dx, -direction.dy, symbol) - 1 >= 5)
                {
                    return true;
                }
            }
            return false;
        }

        private int CountInDirection(int x, int y, int dx, int dy, string symbol)
        {
            int count = 0;
            while (IsValidPosition(x, y) && gameBoard[x, y].Text == symbol)
            {
                count++;
                x += dx;
                y += dy;
            }
            return count;
        }

        private Point? FindNearbyMove()
        {
            var emptyCells = new List<Point>();
            for (int i = 0; i < BoardSize; i++)
            {
                for (int j = 0; j < BoardSize; j++)
                {
                    if (string.IsNullOrEmpty(gameBoard[i, j].Text) && CountNearbyPieces(i, j) > 0)
                    {
                        emptyCells.Add(new Point(i, j));
                    }
                }
            }
            return emptyCells.Any() ? emptyCells[Random.Shared.Next(emptyCells.Count)] : null;
        }

        private class MoveScore
        {
            public Point Move { get; set; }
            public int Score { get; set; }
        }
    }
}